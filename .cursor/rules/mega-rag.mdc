---
description: 
globs: 
alwaysApply: false
---
You are an expert in:
    Python 3.10+
    FastAPI + async programming
    Multi-agent systems (Agno/Phidata)
    Vector search (Qdrant)
    Frontend integration (Gradio/Streamlit)
    Scalable deployments (Spaces, Render, Railway)

✳️ Key Development Principles
    Emphasize simplicity, readability, and modularity.
    Prefer functional and declarative patterns over OOP.
    Use pure functions unless state or side-effects require otherwise.
    Rely on Receive an Object, Return an Object (RORO) pattern.
    Use lower_snake_case for files, functions, and variables.
    Use descriptive, state-revealing names (e.g., has_tool_access, is_valid_query, chunk_document_text).
    Keep utilities, services, routers, models, and schemas in separate folders.
    Prefer @router.get and @router.post with clearly typed response_model.

🧱 Project Structure Conventions
.
├── app/
│   ├── main.py                # FastAPI entrypoint
│   ├── routers/               # route handlers
│   ├── services/              # logic & integrations (qdrant, embedding, agents)
│   ├── models/                # Pydantic schemas
│   ├── utils/                 # chunking, parsing, validation
│   ├── agents/                # agno/phidata agent configs
│   └── config.py              # settings/env loader
├── requirements.txt
└── README.md

⚙️ FastAPI + Async I/O
    Use async def for all I/O-bound operations (file reads, DB calls, API).
    Use def only for sync logic or CPU-bound tasks (e.g., chunking).
    Avoid global state; inject dependencies via Depends(...).
    Prefer FastAPI’s lifespan for startup/shutdown events (not @app.on_event).

🧾 Validation and Error Handling
    Use Pydantic v2 models for all request/response validation.
    Prefer guard clauses and early returns.
    Avoid nested ifs: use if condition: return pattern.
    Use HTTPException(status_code=..., detail=...) for expected client errors.
    Centralize unknown error handling with FastAPI middleware or exception handlers.
    Log all errors using structured logging (e.g., loguru, structlog).

🔍 Document Handling + Embeddings
    Chunk with consistent token/window size.
    Store per-user or per-session embeddings in Qdrant with metadata.
    Clean input: normalize whitespace, remove control chars.
    Embed using sentence-transformers or OpenAI.
    Use UUIDs to isolate user data during session lifespan.

🤖 Agent-Oriented Architecture (Agno/Phidata)

    Define small, focused agents with clear goals:
        RetrieverAgent → get context
        SynthesizerAgent → answer from context
        FallbackAgent → use web, code, tools

    Use a TeamAgent to orchestrate:
        strategy="collaborative" or hierarchical as needed
    Use toolkits (e.g., web search, calculator) via Agno 
    Minimize memory context for performance

📈 Performance Best Practices
    Avoid blocking I/O (file reads, API calls) on request threads.
    Use asyncpg, httpx, or aiofiles for async support.
    Use Redis/memory for short-term caching (e.g., chunk results).
    Lazy-load large datasets; paginate UI results.
    Add /health and /metrics endpoints for monitoring.

🔐 Security & UX
    Validate all file uploads (MIME, size limits).
    Sanitize text inputs and user content.
    Limit request payload size (FastAPI config).
    Auto-clean temp session data (Qdrant, uploads).
    Log user queries for monitoring and agent improvement (with anonymization).

🛠️ Tools and Dependencies
    FastAPI, Pydantic v2
    sentence-transformers, PyMuPDF, pdfminer.six
    qdrant-client, uuid, tqdm
    agno or phidata
    httpx, aiofiles, loguru, python-dotenv

🧪 Testing and DevOps
    Use pytest-asyncio for async tests.
    Mock external calls (embedding, qdrant, tools).
    Use .env.example and enforce via pydantic.BaseSettings.
    Include a Makefile or run.sh for dev setup.


