---
description: 
globs: 
alwaysApply: false
---
You are an expert in:
    Python 3.10+
    FastAPI + async programming
    Multi-agent systems (Agno/Phidata)
    Vector search (Qdrant)
    Frontend integration (Gradio/Streamlit)
    Scalable deployments (Spaces, Render, Railway)

âœ³ï¸ Key Development Principles
    Emphasize simplicity, readability, and modularity.
    Prefer functional and declarative patterns over OOP.
    Use pure functions unless state or side-effects require otherwise.
    Rely on Receive an Object, Return an Object (RORO) pattern.
    Use lower_snake_case for files, functions, and variables.
    Use descriptive, state-revealing names (e.g., has_tool_access, is_valid_query, chunk_document_text).
    Keep utilities, services, routers, models, and schemas in separate folders.
    Prefer @router.get and @router.post with clearly typed response_model.

ğŸ§± Project Structure Conventions
.
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py                # FastAPI entrypoint
â”‚   â”œâ”€â”€ routers/               # route handlers
â”‚   â”œâ”€â”€ services/              # logic & integrations (qdrant, embedding, agents)
â”‚   â”œâ”€â”€ models/                # Pydantic schemas
â”‚   â”œâ”€â”€ utils/                 # chunking, parsing, validation
â”‚   â”œâ”€â”€ agents/                # agno/phidata agent configs
â”‚   â””â”€â”€ config.py              # settings/env loader
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md

âš™ï¸ FastAPI + Async I/O
    Use async def for all I/O-bound operations (file reads, DB calls, API).
    Use def only for sync logic or CPU-bound tasks (e.g., chunking).
    Avoid global state; inject dependencies via Depends(...).
    Prefer FastAPIâ€™s lifespan for startup/shutdown events (not @app.on_event).

ğŸ§¾ Validation and Error Handling
    Use Pydantic v2 models for all request/response validation.
    Prefer guard clauses and early returns.
    Avoid nested ifs: use if condition: return pattern.
    Use HTTPException(status_code=..., detail=...) for expected client errors.
    Centralize unknown error handling with FastAPI middleware or exception handlers.
    Log all errors using structured logging (e.g., loguru, structlog).

ğŸ” Document Handling + Embeddings
    Chunk with consistent token/window size.
    Store per-user or per-session embeddings in Qdrant with metadata.
    Clean input: normalize whitespace, remove control chars.
    Embed using sentence-transformers or OpenAI.
    Use UUIDs to isolate user data during session lifespan.

ğŸ¤– Agent-Oriented Architecture (Agno/Phidata)

    Define small, focused agents with clear goals:
        RetrieverAgent â†’ get context
        SynthesizerAgent â†’ answer from context
        FallbackAgent â†’ use web, code, tools

    Use a TeamAgent to orchestrate:
        strategy="collaborative" or hierarchical as needed
    Use toolkits (e.g., web search, calculator) via Agno 
    Minimize memory context for performance

ğŸ“ˆ Performance Best Practices
    Avoid blocking I/O (file reads, API calls) on request threads.
    Use asyncpg, httpx, or aiofiles for async support.
    Use Redis/memory for short-term caching (e.g., chunk results).
    Lazy-load large datasets; paginate UI results.
    Add /health and /metrics endpoints for monitoring.

ğŸ” Security & UX
    Validate all file uploads (MIME, size limits).
    Sanitize text inputs and user content.
    Limit request payload size (FastAPI config).
    Auto-clean temp session data (Qdrant, uploads).
    Log user queries for monitoring and agent improvement (with anonymization).

ğŸ› ï¸ Tools and Dependencies
    FastAPI, Pydantic v2
    sentence-transformers, PyMuPDF, pdfminer.six
    qdrant-client, uuid, tqdm
    agno or phidata
    httpx, aiofiles, loguru, python-dotenv

ğŸ§ª Testing and DevOps
    Use pytest-asyncio for async tests.
    Mock external calls (embedding, qdrant, tools).
    Use .env.example and enforce via pydantic.BaseSettings.
    Include a Makefile or run.sh for dev setup.


